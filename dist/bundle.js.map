{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/fast-deep-equal/index.js","webpack:///./src/node-convert/sync.ts","webpack:///./src/ops/path.ts","webpack:///./src/ops/convert.ts","webpack:///./src/ops/node.ts","webpack:///./src/apply.ts","webpack:///./src/ops/text.ts","webpack:///./src/ops/mark.ts","webpack:///./src/node-convert/slate.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isArray","Array","keyList","keys","hasProp","equal","a","b","length","arrA","arrB","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","toString","createSyncNode","node","TypeError","__assign","nodes","map","text","from","marks","toSyncDocument","walk","path","reduce","curNode","idx","isTreeNode","JSON","stringify","getAncestor","doc","level","_a","ancestorPath","ancestor","slice","toNumberPath","toJS","toSyncMarkProperties","props","markProps","type","data","toJSON","insertNode","op","parentNode","index","splice","removeNode","mergeNode","prevNode","parentPath","prevIdx","concat","decrementPath","push","apply","_b","applyOperation","slateOp","offset","mark","newPath","position","properties","newProperties","toSyncOp","insertText","removeText","srcParent","srcIndex","_c","destParent","destIndex","moveNode","splitNode","node_assign","node_splitNode","jsonData","setNodeProperties","findIndex","existingMark","fast_deep_equal_default","addMark","existingIdx","removeMark","console","warn","mark_assign","setMark","createSlateNode","slate_assign","join","toSlateDocument","__webpack_exports__"],"mappings":"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","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","import { NodeJSON, DocumentJSON } from '../types/slate';\nimport { SyncNode } from '../types/sync';\n\nexport const createSyncNode = (node: NodeJSON): SyncNode => {\n  if (!node.object) {\n    throw new TypeError(`cannot create node with missing type`);\n  }\n\n  switch(node.object) {\n    case 'document':\n      return {\n        ...node,\n        nodes: node.nodes && node.nodes.map(createSyncNode)\n      }\n    case 'block':\n      return {\n        ...node,\n        nodes: node.nodes && node.nodes.map(createSyncNode)\n      }\n    case 'inline':\n      return {\n        ...node,\n        nodes: node.nodes && node.nodes.map(createSyncNode)\n      }\n    case 'text':\n      return {\n        ...node,\n        text: node.text ? Array.from(node.text) : [],\n        marks: node.marks || []\n      }\n  }\n}\n\nexport const toSyncDocument = (node: DocumentJSON) => createSyncNode(node);","import { SyncTreeNode, SyncNode, SyncDocument } from \"../types/sync\";\nimport { Path } from \"slate\";\n\n// @ts-ignore\nexport const isTreeNode = (node: SyncNode): node is SyncTreeNode => {\n  return (<SyncTreeNode>node).object !== 'text';\n}\n\nexport const walk = (node: SyncTreeNode, path: number[]): SyncNode => {\n  return path.reduce((curNode: SyncNode, idx) => {\n    if (!isTreeNode(curNode) || !curNode.nodes) {\n      throw new TypeError(`path ${path.toString()} does not match tree ${JSON.stringify(node)}`);\n    }\n\n    return curNode.nodes[idx];\n  }, node as SyncNode);\n  // FIXME: ^ that cast is odd\n}\n\nexport const getAncestor = (doc: SyncDocument, path: number[], level=1): [SyncNode, number] => {\n  const [idx, ancestor] = ancestorPath(path, level);\n  return [walk(doc, ancestor), idx]\n}\n\nexport const ancestorPath = (path: number[], level=1): [number, number[]] => {\n  if (level > path.length)  {\n    throw new TypeError('requested ancestor is higher than root')\n  }\n\n  return [path[path.length - level], path.slice(0, path.length - level)]\n}\n\nexport const incrementPath = (path: number[]) => {\n  const [idx, parentPath] = ancestorPath(path);\n  return parentPath.concat([idx + 1]);\n}\n\nexport const decrementPath = (path: number[]) => {\n  const [idx, parentPath] = ancestorPath(path);\n  const prevIdx = idx - 1;\n  if (prevIdx < 0) {\n    throw new TypeError(`node at path ${path} has no sibling before it`);\n  }\n\n  return parentPath.concat([prevIdx]);\n}\n\nexport const toNumberPath = (path: Path | number[]): number[] => {\n  if (typeof path === \"string\") {\n    // return [Number(path)];\n    throw new TypeError(\"cannot handle key-based paths\");\n  } else if (typeof path === \"number\") {\n    return [path];\n  } else if (Array.isArray(path)) {\n    return path;\n  } else {\n    return path.toJS();\n  }\n};","import { Operation, MarkJSON, MarkProperties } from \"slate\";\nimport { createSyncNode } from \"../node-convert/sync\";\nimport { NodeJSON } from \"../types/slate\";\nimport { SyncOperation, SyncMarkProperties } from \"../types/ops\";\nimport { toNumberPath } from \"./path\";\n\nconst toSyncMarkProperties = (props: MarkProperties) => {\n  const markProps: SyncMarkProperties = {}\n\n  if (props.type) {\n    markProps.type = props.type;\n  }\n\n  if (props.data) {\n    // @ts-ignore\n    markProps.data = props.data && (props.data.toJSON ? props.data.toJSON() : props.data)\n  }\n\n  return markProps;\n}\n\n// DO NOT spread objects here; source is a Immutable Record\nexport const toSyncOp = (op: Operation): SyncOperation | null => {\n  switch (op.type) {\n    case \"insert_text\":\n      return {\n        type: op.type,\n\n        offset: op.offset,\n        text: op.text,\n        path: toNumberPath(op.path),\n        marks: op.marks ? op.marks.map(mark => mark.toJSON() as MarkJSON) : []\n      };\n    case \"remove_text\":\n      return {\n        type: op.type,\n\n        offset: op.offset,\n        text: op.text,\n        path: toNumberPath(op.path)\n      };\n    case \"insert_node\":\n      return {\n        type: op.type,\n\n        path: toNumberPath(op.path),\n        node: createSyncNode(op.node.toJSON() as NodeJSON)\n      };\n    case \"move_node\":\n      return {\n        type: op.type,\n\n        path: toNumberPath(op.path),\n        newPath: toNumberPath(op.newPath)\n      };\n    case \"remove_node\":\n      return {\n        type: op.type,\n\n        path: toNumberPath(op.path)\n      };\n    case \"split_node\":\n      return {\n        type: op.type,\n\n        path: toNumberPath(op.path),\n        position: op.position,\n        properties: op.properties\n      };\n    case \"merge_node\":\n      return {\n        type: op.type,\n\n        path: toNumberPath(op.path)\n      };\n    case \"add_mark\":\n      return {\n        type: op.type,\n\n        path: toNumberPath(op.path),\n        mark: op.mark.toJSON() as MarkJSON\n      };\n    case \"remove_mark\":\n      return {\n        type: op.type,\n        path: toNumberPath(op.path),\n        mark: op.mark.toJSON() as MarkJSON\n      };\n    case \"set_node\":\n      return {\n        type: op.type,\n        path: toNumberPath(op.path),\n        newProperties: op.newProperties\n      };\n    case \"set_mark\":\n      return {\n        type: op.type,\n        path: toNumberPath(op.path),\n        properties: toSyncMarkProperties(op.properties),\n        newProperties: toSyncMarkProperties(op.newProperties)\n      };\n    case \"set_selection\":\n    case \"set_value\":\n      // Value-specific operations. These don't apply to doc\n      return null;\n  }\n};\n","import { SyncDocument, SyncText, SyncNode, SyncTreeNode } from \"../types/sync\";\nimport {\n  SyncInsertNodeOperation,\n  SyncMoveNodeOperation,\n  SyncRemoveNodeOperation,\n  SyncSplitNodeOperation,\n  SyncMergeNodeOperation,\n  SyncSetNodeOperation\n} from \"../types/ops\";\nimport { walk, getAncestor, incrementPath, decrementPath } from \"./path\";\n\nexport const insertNode = (\n  doc: SyncDocument,\n  op: SyncInsertNodeOperation\n): SyncDocument => {\n  const [parentNode, index] = getAncestor(doc, op.path);\n\n  if (parentNode.object === \"text\") {\n    throw new TypeError(\"cannot insert node into text node\");\n  }\n\n  parentNode.nodes!.splice(index, 0, op.node);\n\n  return doc;\n};\n\nexport const moveNode = (\n  doc: SyncDocument,\n  op: SyncMoveNodeOperation\n): SyncDocument => {\n  const [srcParent, srcIndex] = getAncestor(doc, op.path);\n  const [destParent, destIndex] = getAncestor(doc, op.newPath);\n\n  if (srcParent.object === \"text\" || destParent.object === \"text\") {\n    throw new TypeError(\"cannot move node as child of a text node\");\n  }\n\n  destParent.nodes!.splice(\n    destIndex,\n    0,\n    ...srcParent.nodes!.splice(srcIndex, 1)\n  );\n\n  return doc;\n};\n\nexport const removeNode = (\n  doc: SyncDocument,\n  op: SyncRemoveNodeOperation\n): SyncDocument => {\n  const [parentNode, index] = getAncestor(doc, op.path);\n\n  if (parentNode.object === \"text\") {\n    throw new TypeError(\"cannot remove node from text node\");\n  }\n\n  parentNode.nodes!.splice(index, 1);\n\n  return doc;\n};\n\nexport const splitNode = (\n  doc: SyncDocument,\n  op: SyncSplitNodeOperation\n): SyncDocument => {\n  const node = walk(doc, op.path);\n\n  let splitNode;\n  if (node.object === \"text\") {\n    splitNode = {\n      object: \"text\",\n      text: node.text.splice(op.position),\n      marks: Array.from(node.marks)\n    } as SyncText;\n  } else {\n    splitNode = {\n      ...node,\n      nodes: node.nodes!.splice(op.position)\n    };\n  }\n\n  return insertNode(doc, {\n    type: \"insert_node\",\n    path: incrementPath(op.path),\n    node: splitNode\n  });\n};\n\nexport const mergeNode = (\n  doc: SyncDocument,\n  op: SyncMergeNodeOperation\n): SyncDocument => {\n  const node = walk(doc, op.path);\n  const prevNode = walk(doc, decrementPath(op.path));\n\n  if (node.object !== prevNode.object) {\n    throw new TypeError(\n      `cannot merge nodes of differing types ${node.object} and ${\n        prevNode.object\n      }`\n    );\n  }\n\n  // fold node into prevNode\n  // FIXME: please don't cast here\n  if (prevNode.object === \"text\") {\n    prevNode.text.push(...(node as SyncText).text);\n  } else {\n    if (prevNode.nodes && (node as SyncTreeNode).nodes) {\n      prevNode.nodes.push(...(node as SyncTreeNode).nodes!);\n    }\n  }\n\n  return removeNode(doc, {\n    type: \"remove_node\",\n    path: op.path\n  });\n};\n\nexport const setNodeProperties = (\n  doc: SyncDocument,\n  op: SyncSetNodeOperation\n): SyncDocument => {\n  const node = walk(doc, op.path);\n\n  const { type, data } = op.newProperties;\n\n  if (type) {\n    // @ts-ignore\n    node.type = type;\n  }\n\n  if (node.object !== \"text\" && data) {\n    const jsonData = data.toJSON ? data.toJSON() : { ...data };\n    node.data = jsonData;\n  }\n\n  return doc;\n};\n","import { Operation } from \"slate\";\nimport { SyncDocument } from \"./types/sync\";\nimport { toSyncOp } from \"./ops/convert\";\nimport { insertText, removeText } from \"./ops/text\";\nimport { insertNode, moveNode, removeNode, splitNode, mergeNode, setNodeProperties } from \"./ops/node\";\nimport { addMark, removeMark, setMark } from \"./ops/mark\";\n\nexport const applyOperation = (doc: SyncDocument, slateOp: Operation): SyncDocument => {\n  const op = toSyncOp(slateOp);\n\n  if (!op) {\n    return doc;\n  }\n\n  switch (op.type) {\n    case 'insert_text':\n      return insertText(doc, op);\n    case 'remove_text':\n      return removeText(doc, op);\n    \n    case 'insert_node':\n      return insertNode(doc, op);\n    case 'move_node':\n      return moveNode(doc, op);\n    case 'remove_node':\n      return removeNode(doc, op);\n    case 'split_node':\n      return splitNode(doc, op);\n    case 'merge_node':\n      return mergeNode(doc, op);\n    case 'set_node':\n      return setNodeProperties(doc, op);\n    \n    case 'add_mark':\n      return addMark(doc, op);\n    case 'remove_mark':\n      return removeMark(doc, op);\n    case 'set_mark':\n      return setMark(doc, op);\n  }\n\n  throw new TypeError('invalid op');\n}","import { walk } from \"./path\";\nimport { SyncDocument } from \"../types/sync\";\nimport { SyncInsertTextOperation, SyncRemoveTextOperation } from \"../types/ops\";\n\nexport const insertText = (doc: SyncDocument, op: SyncInsertTextOperation): SyncDocument => {\n  const node = walk(doc, op.path);\n  if (node.object !== 'text') {\n    throw new TypeError('did not get text node at path');\n  }\n\n  node.text.splice(op.offset, 0, ...Array.from(op.text));\n\n  return doc;\n}\n\nexport const removeText = (doc: SyncDocument, op: SyncRemoveTextOperation): SyncDocument => {\n  const node = walk(doc, op.path);\n  if (node.object !== 'text') {\n    throw new TypeError('did not get text node at path');\n  }\n\n  node.text.splice(op.offset, Array.from(op.text).length);\n\n  return doc;\n}","import { SyncDocument } from \"../types/sync\";\nimport { SyncAddMarkOperation, SyncRemoveMarkOperation, SyncSetMarkOperation } from \"../types/ops\";\nimport { walk } from \"./path\";\nimport equal from 'fast-deep-equal';\n\nexport const addMark = (doc: SyncDocument, op: SyncAddMarkOperation): SyncDocument => {\n  const node = walk(doc, op.path);\n  if (node.object !== 'text') {\n    throw new TypeError('cannot set marks on non-text node');\n  }\n\n  // emulate Set behaviour\n  const existingIdx = node.marks.findIndex(existingMark => \n    existingMark.type === op.mark.type && equal(existingMark.data, op.mark.data)\n  )\n\n  if (existingIdx > -1) {\n    return doc;\n  } \n\n  node.marks.push(op.mark);\n  return doc;\n}\n\nexport const removeMark = (doc: SyncDocument, op: SyncRemoveMarkOperation): SyncDocument => {\n  const node = walk(doc, op.path);\n  if (node.object !== 'text') {\n    throw new TypeError('cannot set marks on non-text node');\n  }\n\n  // emulate Set behaviour\n  const existingIdx = node.marks.findIndex(existingMark => \n    existingMark.type === op.mark.type && equal(existingMark.data, op.mark.data)\n  )\n\n  if (existingIdx === -1) {\n    return doc;\n  }\n\n  node.marks.splice(existingIdx, 1);\n\n  return doc;\n}\n\nexport const setMark = (doc: SyncDocument, op: SyncSetMarkOperation): SyncDocument => {\n  const node = walk(doc, op.path);\n  if (node.object !== 'text') {\n    throw new TypeError('cannot set marks on non-text node');\n  }\n\n  const existingIdx = node.marks.findIndex(existingMark => \n    existingMark.type === op.properties.type && equal(existingMark.data, op.properties.data)\n  )\n\n  if (existingIdx === -1) {\n    console.warn('did not find old mark with properties', op.properties);\n\n    if (!op.newProperties.type) {\n      throw new TypeError('no old mark, and new mark missing type');\n    }\n\n    node.marks.push({\n      object: 'mark',\n      type: op.newProperties.type,\n      ...op.newProperties,\n    });\n  } else  {\n    node.marks[existingIdx] = {\n      object: 'mark',\n      ...node.marks[existingIdx],\n      ...op.newProperties\n    }\n  }\n\n  return doc;\n}","import { NodeJSON } from '../types/slate';\nimport { SyncNode, SyncDocument } from '../types/sync';\n\nexport const createSlateNode = (node: SyncNode): NodeJSON  => {\n  if (!node.object) {\n    throw new TypeError(`cannot create node with missing type`);\n  }\n\n  switch(node.object) {\n    case 'document':\n      return {\n        ...node,\n        nodes: node.nodes && node.nodes.map(createSlateNode)\n      }\n    case 'block':\n      return {\n        ...node,\n        nodes: node.nodes && node.nodes.map(createSlateNode)\n      }\n    case 'inline':\n      return {\n        ...node,\n        nodes: node.nodes && node.nodes.map(createSlateNode)\n      }\n    case 'text':\n      return {\n        ...node,\n        text: node.text.join(''),\n      }\n  }\n}\n\nexport const toSlateDocument = (node: SyncDocument) => createSlateNode(node);","export { applyOperation } from './apply';\nexport { toSyncDocument, toSlateDocument } from './node-convert';"],"sourceRoot":""}